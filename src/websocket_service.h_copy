#pragma once

#include <iostream>
#include <thread>
#include <string>
#include <functional>
#include <map>
#include <mutex>
#include <atomic>
#include <chrono>

// Use the simplified uWebSockets.h header
#include "uWebSockets/App.h"
#include "nlohmann/json.hpp"
#include "CNCConsole.h"
#include "modbus_business.h"

using json = nlohmann::json;

class WebSocketService {
private:
    // Per-socket data
    struct PerSocketData {
        int task_id = -1; // ID of the task this socket is currently running
    };

    // Aggregated task state
    struct TaskState {
        uWS::WebSocket<false, true, PerSocketData>* ws; // Client connection
        int total_sub_tasks;
        int completed_sub_tasks;
        std::chrono::steady_clock::time_point start_time;
    };

    std::map<int, TaskState> active_tasks_;
    std::atomic<int> next_task_id_ = 0;
    std::mutex tasks_mutex_;
    std::thread cleanup_thread_;
    std::atomic<bool> stop_cleanup_ = false;
    const std::chrono::seconds TASK_TIMEOUT = std::chrono::seconds(40);

    int port_;
    std::shared_ptr<ModbusBusiness> modbusBusiness_ptr_;
    std::shared_ptr<CNCConsole> cnc_ptr_;
    int test_task = 4;
    std::string current_name_;
public:
    WebSocketService(int port, std::shared_ptr<CNCConsole> cnc, std::shared_ptr<ModbusBusiness> modbus)
        : port_(port), cnc_ptr_(cnc), modbusBusiness_ptr_(modbus) 
    {
        cleanup_thread_ = std::thread(&WebSocketService::cleanup_loop, this);
    }

    ~WebSocketService() {
        stop_cleanup_ = true;
        if (cleanup_thread_.joinable()) {
            cleanup_thread_.join();
        }
    }

    void run() {
        std::cout << "Attempting to start WebSocket server on port " << port_ << std::endl;

        uWS::App().ws<PerSocketData>("/control", {
            /* Settings */
            .compression = uWS::SHARED_COMPRESSOR,
            .maxPayloadLength = 16 * 1024,
            .idleTimeout = 300,

            /* Handlers */
            .open = [this](auto *ws) {
                handle_open(ws);
            },
            .message = [this](auto *ws, std::string_view message, uWS::OpCode opCode) {
                handle_message(ws, message, opCode);
            },
            .close = [this](auto *ws, int code, std::string_view message) {
                handle_close(ws, code, message);
            }

        }).listen(port_, [this](auto *listen_socket) {
            if (listen_socket) {
                std::cout << "SUCCESS: WebSocket server listening on port " << port_ << std::endl;
            } else {
                std::cerr << "ERROR: Failed to listen on port " << port_ << std::endl;
            }
        }).run();
    }

private:
    void handle_open(uWS::WebSocket<false, true, PerSocketData>* ws) {
        std::cout << "INFO: New client connected." << std::endl;
        // Initialize user data for this connection
        ws->getUserData()->task_id = -1;
    }

    void handle_close(uWS::WebSocket<false, true, PerSocketData>* ws, int code, std::string_view message) {
        std::cout << "INFO: Client disconnected." << std::endl;
        // If the disconnected client had an active task, clean it up
        std::lock_guard<std::mutex> lock(tasks_mutex_);
        int task_id_to_remove = ws->getUserData()->task_id;
        if (task_id_to_remove != -1) {
            active_tasks_.erase(task_id_to_remove);
            if (modbusBusiness_ptr_) {
                modbusBusiness_ptr_->resetTask(task_id_to_remove);
            }
            std::cout << "INFO: Cleaned up active task " << task_id_to_remove << " due to client disconnection." << std::endl;
        }
    }

    void handle_message(uWS::WebSocket<false, true, PerSocketData>* ws, std::string_view message, uWS::OpCode opCode) {
        if (opCode != uWS::TEXT) return;

        try {
            json j = json::parse(message);
	    std::string name_;
	    if(j.contains("name")) { name_ = j["name"]; printf("point index = %s\n",name_.c_str()); }
            if (ws->getUserData()->task_id != -1) {
		printf("current process point index is = %s\n",current_name_.c_str());
                ws->send("{\"status\":\"processing\",\"message\":\"Server is busy with a previous task\"}", uWS::OpCode::TEXT);
                return;
            }
	    current_name_ = name_;
            if (!j.value("enabled", true)) {
                ws->send("{\"status\":\"skipped\",\"message\":\"Command was disabled\"}", uWS::OpCode::TEXT);
                return;
            }
	    if(test_task > 0){
	    	ws->send("{\"status\":\"completed\"}", uWS::OpCode::TEXT);
		test_task--;
		return;
	    }
            int total_sub_tasks = 0;
            if (j.contains("first")) total_sub_tasks++;
            if (j.contains("second")) {
		total_sub_tasks++;
                //if (j["second"].contains("f")) total_sub_tasks++;
                //if (j["second"].contains("g")) total_sub_tasks++;
            }

            if (total_sub_tasks == 0) {
                ws->send("{\"status\":\"error\",\"message\":\"No valid movement data in command\"}", uWS::OpCode::TEXT);
                return;
            }

            int task_id = next_task_id_++;
            ws->getUserData()->task_id = task_id; // Associate task with this socket

            {
                std::lock_guard<std::mutex> lock(tasks_mutex_);
                active_tasks_[task_id] = {ws, total_sub_tasks, 0, std::chrono::steady_clock::now()};
            }
            std::cout << "INFO: Created aggregated task " << task_id << " point index " << name_ << " for client with " << total_sub_tasks << " sub-task(s)." << std::endl;

            auto sub_task_callback = [this, task_id](bool success) {
                std::lock_guard<std::mutex> lock(tasks_mutex_);
                auto it = active_tasks_.find(task_id);
                if (it == active_tasks_.end()) return;

                auto* current_ws = it->second.ws;

                if (!success) {
                    std::cerr << "ERROR: Sub-task for task " << task_id << " point index " << current_name_ << " failed." << std::endl;
                    try { current_ws->send("{\"status\":\"error\",\"message\":\"A sub-task failed.\"}", uWS::OpCode::TEXT); } catch (...) {}
                    current_ws->getUserData()->task_id = -1; // Free up the socket
                    active_tasks_.erase(it);
                    if (modbusBusiness_ptr_) {
                        modbusBusiness_ptr_->resetTask(task_id);
                    }
                    return;
                }

                it->second.completed_sub_tasks++;
                //std::cout << "INFO: Sub-task for task " << task_id << " point index " << current_name_ << " completed. (" << it->second.completed_sub_tasks << "/" << it->second.total_sub_tasks << ")" << std::endl;
                std::cout << "INFO: Sub-task for task " << task_id << " completed. (" << it->second.completed_sub_tasks << "/" << it->second.total_sub_tasks << ")" << std::endl;

                if (it->second.completed_sub_tasks >= it->second.total_sub_tasks) {
                    //std::cout << "SUCCESS: Aggregated task " << task_id << " point index " << current_name_ << " fully completed." << std::endl;
                    std::cout << "SUCCESS: Aggregated task " << task_id << " point index " << " fully completed." << std::endl;
                    try { current_ws->send("{\"status\":\"completed\"}", uWS::OpCode::TEXT); } catch (...) {}
                    current_ws->getUserData()->task_id = -1; // Free up the socket
                    active_tasks_.erase(it);
                    if (modbusBusiness_ptr_) {
                        modbusBusiness_ptr_->resetTask(task_id);
                    }
                }
            };

            ws->send("{\"status\":\"processing\"}", uWS::OpCode::TEXT);

            if (j.contains("first")) {
                if (cnc_ptr_) {
                    const auto& g1 = j["first"];
                    uint64_t vx = g1.value("vx", 0), vz = g1.value("vz", 0), vc = g1.value("vc", 0);
                    uint64_t speed = std::max({vx, vz, vc, (uint64_t)1});
                    if (speed == 0) speed = 25000;
                    // Call the refactored moveAbsolute2, which now contains all the logic
                    cnc_ptr_->getYX20KController()->moveAbsolute2(g1.value("x", -80000.0), 0.0, g1.value("z", -80000.0), g1.value("c", -80000.0), speed, sub_task_callback);
                } else { sub_task_callback(false); }
            }

            if (j.contains("second")) {
                if (modbusBusiness_ptr_) {
                    const auto& g2 = j["second"];
                    if (g2.contains("f")) { int speed_ = g2.value("vf", (int)-8000); if(speed_ > 0) modbusBusiness_ptr_->axisRunSpeed("X", std::to_string(speed_)); }
                    if (g2.contains("g")) { int speed_ = g2.value("vg", (int)-8000); if(speed_ > 0) modbusBusiness_ptr_->axisRunSpeed("Z", std::to_string(speed_)); }
                    if (g2.contains("f") || g2.contains("g")) std::this_thread::sleep_for(std::chrono::milliseconds(200));
		    #if 0
                    if (g2.contains("f")) {
                        ModbusBusiness::Para para_f; para_f.axis = "X"; para_f.value = std::to_string(static_cast<int>(g2.value("f", 0.0)));
                        modbusBusiness_ptr_->pushData(para_f, sub_task_callback, task_id);
                    }
                    if (g2.contains("g")) {
                        ModbusBusiness::Para para_g; para_g.axis = "Z"; para_g.value = std::to_string(static_cast<int>(g2.value("g", 0.0)));
                        modbusBusiness_ptr_->pushData(para_g, sub_task_callback, task_id);
                    }
		    #else
		    ModbusBusiness::CompositeMovementTask task;
                    task.x_value = std::to_string(g2.value("f", (int)-80000));
                    task.z_value = std::to_string(g2.value("g", (int)-80000));
                    modbusBusiness_ptr_->pushCompositeTask(task, sub_task_callback, task_id);
		    #endif
                } else {
                    if (j["second"].contains("f")) sub_task_callback(false);
                    if (j["second"].contains("g")) sub_task_callback(false);
                }
            }

        } catch (const std::exception& e) {
            std::cerr << "ERROR: Exception in handle_message: " << e.what() << std::endl;
            ws->send("{\"status\":\"error\",\"message\":\"An internal error occurred\"}", uWS::OpCode::TEXT);
            ws->getUserData()->task_id = -1; // Ensure socket is freed on error
        }
    }

    void cleanup_loop() {
        while (!stop_cleanup_) {
            std::this_thread::sleep_for(std::chrono::seconds(5));
            std::lock_guard<std::mutex> lock(tasks_mutex_);
            
            auto now = std::chrono::steady_clock::now();
            for (auto it = active_tasks_.begin(); it != active_tasks_.end(); ) {
                if (std::chrono::duration_cast<std::chrono::seconds>(now - it->second.start_time) > TASK_TIMEOUT) {
                    int task_id_to_cancel = it->first;
                    std::cerr << "ERROR: Task " << task_id_to_cancel << " point index " << current_name_ << " timed out." << std::endl;
                    try {
                        it->second.ws->send("{\"status\":\"error\",\"message\":\"Task timed out\"}", uWS::OpCode::TEXT);
                        it->second.ws->getUserData()->task_id = -1; // Free up the socket
                    } catch (...) { /* Ignore send errors */ }
                    
                    // Notify controllers to cancel the task
                    if (modbusBusiness_ptr_) {
                        modbusBusiness_ptr_->resetTask(task_id_to_cancel);
                    }
                    // NOTE: If CNCConsole also had long-running state, it would need a similar resetTask method.

                    it = active_tasks_.erase(it);
                } else {
                    ++it;
                }
            }
        }
    }
};
